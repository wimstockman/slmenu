Alleen in /home/wim/mygithub/slmenu/: .git
Alleen in /home/wim/mygithub/slmenu/: .gitignore
Alleen in /home/wim/mygithub/slmenu/: patch_keyvalue_slmenu
Alleen in /home/wim/mygithub/slmenu/: README.md
Alleen in /home/wim/mygithub/slmenu/: slmenu
diff -u /tmp/rafaelgg-slmenu-7e74fa5db73e/slmenu.1 /home/wim/mygithub/slmenu/slmenu.1
--- /tmp/rafaelgg-slmenu-7e74fa5db73e/slmenu.1	2012-01-22 15:38:54.000000000 +0100
+++ /home/wim/mygithub/slmenu/slmenu.1	2020-04-12 23:07:24.620149035 +0200
@@ -11,6 +11,10 @@
 .RB [ \-p
 .IR prompt ]
 .RB [ \-v ]
+.RB [ \-m
+.IR mode ]
+.RB [ \-d
+.IR delimiter ]
 .SH DESCRIPTION
 .B slmenu
 is a dynamic menu for the console, based on the wonderful
@@ -38,6 +42,12 @@
 .BI \-p " prompt"
 defines the prompt to be displayed to the left of the input field.
 .TP
+.BI \-m " mode"
+defines the mode default is 0 ; 1 is for each line there is a key and value ; 2 mixed mode some have keys 
+.TP
+.BI \-d " delimiter"
+defines the delimiter for the key value mode default is TAB 
+.TP
 .B \-v
 prints version information to stdout, then exits.
 .SH USAGE
diff -u /tmp/rafaelgg-slmenu-7e74fa5db73e/slmenu.c /home/wim/mygithub/slmenu/slmenu.c
--- /tmp/rafaelgg-slmenu-7e74fa5db73e/slmenu.c	2012-01-22 15:38:54.000000000 +0100
+++ /home/wim/mygithub/slmenu/slmenu.c	2020-04-12 22:59:42.991047734 +0200
@@ -25,7 +25,7 @@
 
 typedef struct Item Item;
 struct Item {
-	char *text;
+	char *text, *value;
 	Item *left, *right;
 };
 
@@ -50,6 +50,7 @@
 static int    barpos = 0;
 static int    mw, mh;
 static int    lines = 0;
+static int    mode = 0;
 static int    inputw, promptw;
 static size_t cursor;
 static char  *prompt = NULL;
@@ -58,7 +59,7 @@
 static Item  *prev, *curr, *next, *sel;
 static struct termios tio_old, tio_new;
 static int  (*fstrncmp)(const char *, const char *, size_t) = strncmp;
-
+char delim[2] = "\t";
 void
 appenditem(Item *item, Item **list, Item **last) {
 	if(!*last)
@@ -246,16 +247,25 @@
 void
 readstdin() {
 	char buf[sizeof text], *p, *maxstr = NULL;
+	char *key,*value;
 	size_t i, max = 0, size = 0;
-
 	for(i = 0; fgets(buf, sizeof buf, stdin); i++) {
 		if(i+1 >= size / sizeof *items)
 			if(!(items = realloc(items, (size += BUFSIZ))))
 				die("Can't realloc.");
 		if((p = strchr(buf, '\n')))
 			*p = '\0';
-		if(!(items[i].text = strdup(buf)))
-			die("Can't strdup.");
+		if ((mode==1) || (mode==2))
+		{
+			/* get the token */
+			key  = strtok(buf, delim);
+			if (key == NULL && mode ==1)die("No Key Found");
+			if (key == NULL && mode ==2)value = key;
+			if (key != NULL && mode ==1)value  = strtok(NULL, delim);
+			if(!(items[i].text = strdup(key))) die("Can't strdup.");
+			if(!(items[i].value = strdup(value))) die("Can't strdup.");
+		}
+		else { if(!(items[i].text = strdup(buf))) die("Can't strdup.");}
 		if(strlen(items[i].text) > max)
 			max = textw(maxstr = items[i].text);
 	}
@@ -372,14 +382,17 @@
 			return EXIT_FAILURE;
 		case CONTROL('M'): /* Return */
 		case CONTROL('J'):
+			if (mode==0){
 			if(sel) strncpy(text, sel->text, sizeof text); /* Complete the input first, when hitting return */
 			cursor = strlen(text);
 			match(TRUE);
-			drawmenu();
+			}
 			/* fallthrough */
 		case CONTROL(']'):
 		case CONTROL('\\'): /* These are usually close enough to RET to replace Shift+RET, again due to console limitations */
-			puts(text);
+			if(mode==0) puts(sel->text);
+			else  puts(sel->value);
+			
 			return EXIT_SUCCESS;
 		case CONTROL('A'):
 			if(sel == matches) {
@@ -538,7 +551,6 @@
 int
 main(int argc, char **argv) {
 	int i;
-
 	for(i=0; i<argc; i++)
 		/* single flags */
 		if(!strcmp(argv[i], "-v")) {
@@ -556,7 +568,22 @@
 			prompt=argv[++i];
 		else if(!strcmp(argv[i], "-l"))
 			lines = atoi(argv[++i]);
-
+		else if(!strcmp(argv[i], "-m")){
+			mode = atoi(argv[++i]);
+			if (mode > 2) die(" Usage -m 0 normal; -m 1 keyvalue ; -m 2 mixed");
+			}			
+		else if(!strcmp(argv[i], "-d")){
+			i = i + 1;
+			if (argv[i] == NULL || argv[i][0] == '\0') delim[0]='\t';
+			else if (argv[i][0] == '\\' && argv[i][1] == 't')
+				delim[0]='\t';
+			else if (argv[i][0] != '\\' && argv[i][1] != '\0')
+				die("the delimiter must be a single character"); 
+			else{
+			delim[0]=argv[i][0];
+			}
+			delim[1]='\0';
+			}
 	readstdin();
 	setup();
 	i = run();
Alleen in /home/wim/mygithub/slmenu/: slmenu.o
Alleen in /home/wim/mygithub/slmenu/: test.txt
